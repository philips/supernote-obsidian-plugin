"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readData = exports.getByteLength = void 0;
let types = new Map([
    [1, [1, readByte]],
    [2, [1, readASCII]],
    [3, [2, readShort]],
    [4, [4, readLong]],
    [5, [8, readRational]],
    [6, [1, readSByte]],
    [7, [1, readByte]],
    [8, [2, readSShort]],
    [9, [4, readSLong]],
    [10, [8, readSRational]],
    [11, [4, readFloat]],
    [12, [8, readDouble]], // DOUBLE
]);
function getByteLength(type, count) {
    const val = types.get(type);
    if (!val)
        throw new Error(`type not found: ${type}`);
    return val[0] * count;
}
exports.getByteLength = getByteLength;
function readData(decoder, type, count) {
    const val = types.get(type);
    if (!val)
        throw new Error(`type not found: ${type}`);
    return val[1](decoder, count);
}
exports.readData = readData;
function readByte(decoder, count) {
    if (count === 1)
        return decoder.readUint8();
    let array = new Uint8Array(count);
    for (let i = 0; i < count; i++) {
        array[i] = decoder.readUint8();
    }
    return array;
}
function readASCII(decoder, count) {
    let strings = [];
    let currentString = '';
    for (let i = 0; i < count; i++) {
        let char = String.fromCharCode(decoder.readUint8());
        if (char === '\0') {
            strings.push(currentString);
            currentString = '';
        }
        else {
            currentString += char;
        }
    }
    if (strings.length === 1) {
        return strings[0];
    }
    else {
        return strings;
    }
}
function readShort(decoder, count) {
    if (count === 1)
        return decoder.readUint16();
    let array = new Uint16Array(count);
    for (let i = 0; i < count; i++) {
        array[i] = decoder.readUint16();
    }
    return array;
}
function readLong(decoder, count) {
    if (count === 1)
        return decoder.readUint32();
    let array = new Uint32Array(count);
    for (let i = 0; i < count; i++) {
        array[i] = decoder.readUint32();
    }
    return array;
}
function readRational(decoder, count) {
    if (count === 1) {
        return decoder.readUint32() / decoder.readUint32();
    }
    let rationals = new Array(count);
    for (let i = 0; i < count; i++) {
        rationals[i] = decoder.readUint32() / decoder.readUint32();
    }
    return rationals;
}
function readSByte(decoder, count) {
    if (count === 1)
        return decoder.readInt8();
    let array = new Int8Array(count);
    for (let i = 0; i < count; i++) {
        array[i] = decoder.readInt8();
    }
    return array;
}
function readSShort(decoder, count) {
    if (count === 1)
        return decoder.readInt16();
    let array = new Int16Array(count);
    for (let i = 0; i < count; i++) {
        array[i] = decoder.readInt16();
    }
    return array;
}
function readSLong(decoder, count) {
    if (count === 1)
        return decoder.readInt32();
    let array = new Int32Array(count);
    for (let i = 0; i < count; i++) {
        array[i] = decoder.readInt32();
    }
    return array;
}
function readSRational(decoder, count) {
    if (count === 1) {
        return decoder.readInt32() / decoder.readInt32();
    }
    let rationals = new Array(count);
    for (let i = 0; i < count; i++) {
        rationals[i] = decoder.readInt32() / decoder.readInt32();
    }
    return rationals;
}
function readFloat(decoder, count) {
    if (count === 1)
        return decoder.readFloat32();
    let array = new Float32Array(count);
    for (let i = 0; i < count; i++) {
        array[i] = decoder.readFloat32();
    }
    return array;
}
function readDouble(decoder, count) {
    if (count === 1)
        return decoder.readFloat64();
    let array = new Float64Array(count);
    for (let i = 0; i < count; i++) {
        array[i] = decoder.readFloat64();
    }
    return array;
}
//# sourceMappingURL=ifdValue.js.map